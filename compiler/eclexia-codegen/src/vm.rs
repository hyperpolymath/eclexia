// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

//! Bytecode virtual machine.
//!
//! Executes bytecode generated by the bytecode backend.

use crate::bytecode::{BytecodeModule, Instruction};
use eclexia_ast::dimension::Dimension;
use eclexia_ast::types::{Ty, PrimitiveTy};
use smol_str::SmolStr;
use std::collections::{HashMap, HashSet};

/// A value on the VM stack
#[derive(Debug, Clone)]
pub enum Value {
    /// Unit value (no data)
    Unit,
    /// Boolean value
    Bool(bool),
    /// 64-bit signed integer
    Int(i64),
    /// 64-bit floating-point number
    Float(f64),
    /// Heap-allocated string
    String(String),
    /// Unicode character
    Char(char),
    /// Function reference by index into the module's function table
    Function(usize),
    /// Exclusive range (start..end)
    Range(i64, i64),
    /// Inclusive range (start..=end)
    RangeInclusive(i64, i64),
}

impl Value {
    /// Convert to boolean for conditional jumps
    pub fn as_bool(&self) -> Result<bool, VmError> {
        match self {
            Value::Bool(b) => Ok(*b),
            Value::Int(i) => Ok(*i != 0),
            Value::Float(f) => Ok(*f != 0.0),
            _ => Err(VmError::TypeError("Cannot convert to boolean".to_string())),
        }
    }

    /// Convert to integer
    pub fn as_int(&self) -> Result<i64, VmError> {
        match self {
            Value::Int(i) => Ok(*i),
            Value::Bool(b) => Ok(if *b { 1 } else { 0 }),
            Value::Float(f) => Ok(*f as i64),
            Value::Char(c) => Ok(*c as i64),
            _ => Err(VmError::TypeError("Cannot convert to integer".to_string())),
        }
    }

    /// Convert to float
    pub fn as_float(&self) -> Result<f64, VmError> {
        match self {
            Value::Float(f) => Ok(*f),
            Value::Int(i) => Ok(*i as f64),
            Value::Bool(b) => Ok(if *b { 1.0 } else { 0.0 }),
            _ => Err(VmError::TypeError("Cannot convert to float".to_string())),
        }
    }
}

/// VM execution error
#[derive(Debug, Clone)]
pub enum VmError {
    /// Stack underflow
    StackUnderflow,

    /// Stack overflow
    StackOverflow,

    /// Invalid instruction
    InvalidInstruction(String),

    /// Type error
    TypeError(String),

    /// Missing function
    MissingFunction(usize),

    /// Invalid jump target
    InvalidJump(usize),

    /// Division by zero
    DivisionByZero,

    /// Out of bounds access
    OutOfBounds { index: usize, size: usize },
}

impl std::fmt::Display for VmError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VmError::StackUnderflow => write!(f, "Stack underflow"),
            VmError::StackOverflow => write!(f, "Stack overflow"),
            VmError::InvalidInstruction(msg) => write!(f, "Invalid instruction: {}", msg),
            VmError::TypeError(msg) => write!(f, "Type error: {}", msg),
            VmError::MissingFunction(idx) => write!(f, "Missing function: {}", idx),
            VmError::InvalidJump(target) => write!(f, "Invalid jump target: {}", target),
            VmError::DivisionByZero => write!(f, "Division by zero"),
            VmError::OutOfBounds { index, size } => {
                write!(f, "Out of bounds: index {} >= size {}", index, size)
            }
        }
    }
}

impl std::error::Error for VmError {}

/// Call frame for function calls
#[derive(Debug, Clone)]
pub struct CallFrame {
    /// Function being executed
    pub function_idx: usize,

    /// Instruction pointer
    pub ip: usize,

    /// Base pointer for local variables
    pub bp: usize,
}

/// Resource tracking entry
#[derive(Debug, Clone)]
pub struct ResourceUsage {
    /// Resource name
    pub resource: SmolStr,

    /// Dimension
    pub dimension: Dimension,

    /// Amount consumed
    pub amount: f64,
}

/// Debug event
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DebugEvent {
    /// Hit a breakpoint
    Breakpoint,
    /// Single step
    Step,
}

/// Action to take after a debug event
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DebugAction {
    /// Continue execution
    Continue,
    /// Step to next instruction
    Step,
    /// Pause execution (return from execute)
    Pause,
}

/// Virtual machine state
pub struct VirtualMachine {
    /// Bytecode module being executed
    module: BytecodeModule,

    /// Value stack
    stack: Vec<Value>,

    /// Call stack
    call_stack: Vec<CallFrame>,

    /// Local variables (flat array indexed by BP + local_idx)
    locals: Vec<Value>,

    /// Resource usage tracking
    resources: Vec<ResourceUsage>,

    /// Stack size limit
    stack_limit: usize,

    /// Call stack depth limit
    call_limit: usize,

    /// Debug mode enabled
    debug_mode: bool,

    /// Breakpoints (function_idx, instruction_idx)
    breakpoints: HashSet<(usize, usize)>,

    /// Single-step mode
    single_step: bool,

    /// Paused at current instruction
    paused: bool,
}

impl VirtualMachine {
    /// Create a new VM with the given bytecode module
    pub fn new(module: BytecodeModule) -> Self {
        Self {
            module,
            stack: Vec::new(),
            call_stack: Vec::new(),
            locals: Vec::new(),
            resources: Vec::new(),
            stack_limit: 10000,
            call_limit: 1000,
            debug_mode: false,
            breakpoints: HashSet::new(),
            single_step: false,
            paused: false,
        }
    }

    /// Enable debug mode
    pub fn enable_debug(&mut self) {
        self.debug_mode = true;
    }

    /// Disable debug mode
    pub fn disable_debug(&mut self) {
        self.debug_mode = false;
        self.single_step = false;
    }

    /// Set a breakpoint at the given function and instruction
    pub fn set_breakpoint(&mut self, func_idx: usize, inst_idx: usize) {
        self.breakpoints.insert((func_idx, inst_idx));
    }

    /// Remove a breakpoint
    pub fn remove_breakpoint(&mut self, func_idx: usize, inst_idx: usize) {
        self.breakpoints.remove(&(func_idx, inst_idx));
    }

    /// Clear all breakpoints
    pub fn clear_breakpoints(&mut self) {
        self.breakpoints.clear();
    }

    /// Enable single-step mode
    pub fn enable_single_step(&mut self) {
        self.single_step = true;
    }

    /// Disable single-step mode
    pub fn disable_single_step(&mut self) {
        self.single_step = false;
    }

    /// Check if execution is paused
    pub fn is_paused(&self) -> bool {
        self.paused
    }

    /// Resume execution
    pub fn resume(&mut self) {
        self.paused = false;
    }

    /// Step one instruction (enables single-step and resumes)
    pub fn step_one(&mut self) {
        self.single_step = true;
        self.paused = false;
    }

    /// Continue execution after a debug pause.
    /// Returns the final value when the program finishes, or `Value::Unit` if paused again.
    pub fn continue_running(&mut self) -> Result<Value, VmError> {
        self.paused = false;
        self.execute()
    }

    /// Step one instruction and return.
    /// Returns `Value::Unit` if paused (normal), or the final value if the program ends.
    pub fn step_instruction(&mut self) -> Result<Value, VmError> {
        self.single_step = true;
        self.paused = false;
        self.execute()
    }

    /// Get current stack
    pub fn get_stack(&self) -> &[Value] {
        &self.stack
    }

    /// Get current locals
    pub fn get_locals(&self) -> &[Value] {
        &self.locals
    }

    /// Get current call stack
    pub fn get_call_stack(&self) -> &[CallFrame] {
        &self.call_stack
    }

    /// Get current resource usage
    pub fn get_resources(&self) -> &[ResourceUsage] {
        &self.resources
    }

    /// Get module
    pub fn get_module(&self) -> &BytecodeModule {
        &self.module
    }

    /// Execute the module's entry point
    pub fn run(&mut self) -> Result<Value, VmError> {
        let entry_idx = self.module.entry_point
            .ok_or_else(|| VmError::MissingFunction(0))?;

        self.call_function(entry_idx, &[])?;
        self.execute()
    }

    /// Execute a specific function
    pub fn call_function(&mut self, func_idx: usize, args: &[Value]) -> Result<(), VmError> {
        if func_idx >= self.module.functions.len() {
            return Err(VmError::MissingFunction(func_idx));
        }

        if self.call_stack.len() >= self.call_limit {
            return Err(VmError::StackOverflow);
        }

        let func = &self.module.functions[func_idx];

        // Set up call frame
        let bp = self.locals.len();
        let frame = CallFrame {
            function_idx: func_idx,
            ip: 0,
            bp,
        };

        self.call_stack.push(frame);

        // Initialize locals with arguments and allocate space for local variables
        for arg in args {
            self.locals.push(arg.clone());
        }

        // Allocate space for remaining locals
        let remaining_locals = func.local_count.saturating_sub(args.len() as u32);
        for _ in 0..remaining_locals {
            self.locals.push(Value::Unit);
        }

        Ok(())
    }

    /// Main execution loop
    fn execute(&mut self) -> Result<Value, VmError> {
        loop {
            let frame = self.call_stack.last().ok_or(VmError::StackUnderflow)?;
            let func_idx = frame.function_idx;
            let ip = frame.ip;
            let call_depth_before = self.call_stack.len();

            // Check for breakpoint or single-step mode
            if self.debug_mode && !self.paused {
                let at_breakpoint = self.breakpoints.contains(&(func_idx, ip));
                if at_breakpoint || self.single_step {
                    // Pause execution
                    self.paused = true;
                    // If single-stepping, disable it so we pause at next instruction
                    if self.single_step {
                        self.single_step = false;
                    }
                    // Return control to debugger
                    return Ok(Value::Unit);
                }
            }

            // Clone the instruction to avoid borrow conflicts
            let inst = {
                let func = &self.module.functions[func_idx];
                if ip >= func.instructions.len() {
                    return Err(VmError::InvalidJump(ip));
                }
                func.instructions[ip].clone()
            };

            // Debug
            if self.debug_mode {
                eprintln!("Exec: func={}, ip={}, inst={:?}, stack={}, locals={}, call_depth={}",
                         func_idx, ip, inst, self.stack.len(), self.locals.len(), call_depth_before);
            }

            // Execute instruction
            match self.execute_instruction(&inst)? {
                ExecutionResult::Continue => {
                    // Increment IP only if we're still in the same function
                    // (Call instructions push a new frame, so we don't want to increment)
                    let call_depth_after = self.call_stack.len();
                    if call_depth_after == call_depth_before {
                        if let Some(frame) = self.call_stack.last_mut() {
                            frame.ip += 1;
                        }
                    }
                }
                ExecutionResult::Jump(target) => {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.ip = target;
                    }
                }
                ExecutionResult::Return(value) => {
                    // Pop call frame
                    self.call_stack.pop();

                    // If no more frames, return the value
                    if self.call_stack.is_empty() {
                        self.locals.clear();
                        return Ok(value);
                    }

                    // Clean up locals - truncate to caller's bp + caller's local count
                    if let Some(frame) = self.call_stack.last() {
                        let caller_func = &self.module.functions[frame.function_idx];
                        let caller_locals_end = frame.bp + caller_func.local_count as usize;
                        self.locals.truncate(caller_locals_end);
                    }

                    // Push return value onto stack
                    self.push(value)?;

                    // Advance caller's IP past the call instruction
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.ip += 1;
                    }
                }
            }
        }
    }

    /// Execute a single instruction
    fn execute_instruction(
        &mut self,
        inst: &Instruction,
    ) -> Result<ExecutionResult, VmError> {
        match inst {
            // Stack operations
            Instruction::PushInt(i) => {
                self.push(Value::Int(*i))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushFloat(f) => {
                self.push(Value::Float(*f))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushBool(b) => {
                self.push(Value::Bool(*b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushString(idx) => {
                let s = self.module.strings.get(*idx)
                    .ok_or_else(|| VmError::OutOfBounds { index: *idx, size: self.module.strings.len() })?;
                self.push(Value::String(s.clone()))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushUnit => {
                self.push(Value::Unit)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LoadLocal(idx) => {
                let bp = self.call_stack.last().ok_or(VmError::StackUnderflow)?.bp;
                let local_idx = bp + (*idx as usize);

                let value = self.locals.get(local_idx)
                    .ok_or_else(|| VmError::OutOfBounds { index: local_idx, size: self.locals.len() })?
                    .clone();

                self.push(value)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::StoreLocal(idx) => {
                let value = self.pop()?;
                let bp = self.call_stack.last().ok_or(VmError::StackUnderflow)?.bp;
                let local_idx = bp + (*idx as usize);

                if local_idx >= self.locals.len() {
                    return Err(VmError::OutOfBounds { index: local_idx, size: self.locals.len() });
                }

                self.locals[local_idx] = value;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Dup => {
                let value = self.peek()?.clone();
                self.push(value)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Pop => {
                self.pop()?;
                Ok(ExecutionResult::Continue)
            }

            // Arithmetic - Integer
            Instruction::AddInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_add(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::SubInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_sub(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::MulInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_mul(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::DivInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                if b == 0 {
                    return Err(VmError::DivisionByZero);
                }
                self.push(Value::Int(a / b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::RemInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                if b == 0 {
                    return Err(VmError::DivisionByZero);
                }
                self.push(Value::Int(a % b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NegInt => {
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(-a))?;
                Ok(ExecutionResult::Continue)
            }

            // Arithmetic - Float
            Instruction::AddFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a + b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::SubFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a - b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::MulFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a * b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::DivFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a / b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NegFloat => {
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(-a))?;
                Ok(ExecutionResult::Continue)
            }

            // Comparison - Integer
            Instruction::EqInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a == b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a != b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LtInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a < b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a <= b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GtInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a > b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a >= b))?;
                Ok(ExecutionResult::Continue)
            }

            // Comparison - Float
            Instruction::EqFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a == b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a != b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LtFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a < b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a <= b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GtFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a > b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a >= b))?;
                Ok(ExecutionResult::Continue)
            }

            // Logical
            Instruction::And => {
                let b = self.pop()?.as_bool()?;
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(a && b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Or => {
                let b = self.pop()?.as_bool()?;
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(a || b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Not => {
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(!a))?;
                Ok(ExecutionResult::Continue)
            }

            // Bitwise
            Instruction::BitAnd => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a & b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitOr => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a | b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitXor => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a ^ b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Shl => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a << b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Shr => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a >> b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitNot => {
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(!a))?;
                Ok(ExecutionResult::Continue)
            }

            // Range
            Instruction::Range => {
                let end = self.pop()?.as_int()?;
                let start = self.pop()?.as_int()?;
                self.push(Value::Range(start, end))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::RangeInclusive => {
                let end = self.pop()?.as_int()?;
                let start = self.pop()?.as_int()?;
                self.push(Value::RangeInclusive(start, end))?;
                Ok(ExecutionResult::Continue)
            }

            // Control flow
            Instruction::Jump(target) => {
                Ok(ExecutionResult::Jump(*target))
            }

            Instruction::JumpIf(target) => {
                let cond = self.pop()?.as_bool()?;
                if cond {
                    Ok(ExecutionResult::Jump(*target))
                } else {
                    Ok(ExecutionResult::Continue)
                }
            }

            Instruction::JumpIfNot(target) => {
                let cond = self.pop()?.as_bool()?;
                if !cond {
                    Ok(ExecutionResult::Jump(*target))
                } else {
                    Ok(ExecutionResult::Continue)
                }
            }

            Instruction::Return => {
                Ok(ExecutionResult::Return(Value::Unit))
            }

            Instruction::ReturnValue => {
                let value = self.pop()?;
                Ok(ExecutionResult::Return(value))
            }

            // Function calls
            Instruction::Call(func_idx, arg_count) => {
                let mut args = Vec::new();
                for _ in 0..*arg_count {
                    args.push(self.pop()?);
                }
                args.reverse();

                self.call_function(*func_idx, &args)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::CallIndirect(arg_count) => {
                let func_val = self.pop()?;
                let func_idx = match func_val {
                    Value::Function(idx) => idx,
                    _ => return Err(VmError::TypeError(
                        "CallIndirect requires a Function value on the stack".to_string()
                    )),
                };

                let mut args = Vec::new();
                for _ in 0..*arg_count {
                    args.push(self.pop()?);
                }
                args.reverse();

                self.call_function(func_idx, &args)?;
                Ok(ExecutionResult::Continue)
            }

            // Resource tracking
            Instruction::TrackResource { resource, dimension } => {
                let amount = self.pop()?.as_float()?;
                self.resources.push(ResourceUsage {
                    resource: resource.clone(),
                    dimension: *dimension,
                    amount,
                });
                Ok(ExecutionResult::Continue)
            }

            Instruction::ShadowPriceHook { resource: _, dimension: _ } => {
                // Shadow price hook - in a real implementation, this would
                // query the runtime for current shadow prices
                Ok(ExecutionResult::Continue)
            }

            // Type operations
            Instruction::Cast { from: _, to } => {
                let value = self.pop()?;
                let converted = match to {
                    Ty::Primitive(PrimitiveTy::Int) => {
                        Value::Int(value.as_int()?)
                    }
                    Ty::Primitive(PrimitiveTy::Float) => {
                        Value::Float(value.as_float()?)
                    }
                    Ty::Primitive(PrimitiveTy::Bool) => {
                        Value::Bool(value.as_bool()?)
                    }
                    Ty::Primitive(PrimitiveTy::String) => {
                        let s = match &value {
                            Value::Int(i) => format!("{}", i),
                            Value::Float(f) => format!("{}", f),
                            Value::Bool(b) => format!("{}", b),
                            Value::Char(c) => format!("{}", c),
                            Value::String(s) => s.clone(),
                            Value::Unit => "()".to_string(),
                            Value::Function(idx) => format!("<function {}>", idx),
                            Value::Range(start, end) => format!("{}..{}", start, end),
                            Value::RangeInclusive(start, end) => format!("{}..={}", start, end),
                        };
                        Value::String(s)
                    }
                    _ => {
                        // For unsupported or identity casts, pass through
                        value
                    }
                };
                self.push(converted)?;
                Ok(ExecutionResult::Continue)
            }

            // Debugging
            Instruction::DebugPrint => {
                let value = self.peek()?;
                println!("DEBUG: {:?}", value);
                Ok(ExecutionResult::Continue)
            }

            // Push function reference
            Instruction::PushFunction(idx) => {
                self.push(Value::Function(*idx))?;
                Ok(ExecutionResult::Continue)
            }

            // Field access (simplified: fields not resolved in VM yet, leave base on stack)
            Instruction::FieldAccess(_field) => {
                // Base value is already on the stack; in a full implementation
                // we would resolve the field. For now, leave the base value as-is.
                Ok(ExecutionResult::Continue)
            }

            // Index access (simplified: pop index and base, push base back)
            Instruction::IndexAccess => {
                let _index = self.pop()?;
                // Base value remains on the stack. In a full implementation,
                // we would perform the index operation on the base value.
                Ok(ExecutionResult::Continue)
            }

            // Exponentiation
            Instruction::PowInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_pow(b as u32)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PowFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a.powf(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Nop => Ok(ExecutionResult::Continue),
        }
    }

    /// Push a value onto the stack
    fn push(&mut self, value: Value) -> Result<(), VmError> {
        if self.stack.len() >= self.stack_limit {
            return Err(VmError::StackOverflow);
        }
        self.stack.push(value);
        Ok(())
    }

    /// Pop a value from the stack
    fn pop(&mut self) -> Result<Value, VmError> {
        self.stack.pop().ok_or(VmError::StackUnderflow)
    }

    /// Peek at the top of the stack
    fn peek(&self) -> Result<&Value, VmError> {
        self.stack.last().ok_or(VmError::StackUnderflow)
    }

    /// Get resource usage statistics
    pub fn get_resource_usage(&self) -> HashMap<SmolStr, f64> {
        let mut usage = HashMap::new();
        for res in &self.resources {
            *usage.entry(res.resource.clone()).or_insert(0.0) += res.amount;
        }
        usage
    }
}

/// Result of instruction execution
enum ExecutionResult {
    /// Continue to next instruction
    Continue,

    /// Jump to target instruction
    Jump(usize),

    /// Return from function
    Return(Value),
}
