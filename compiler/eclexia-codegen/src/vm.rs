// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

//! Bytecode virtual machine.
//!
//! Executes bytecode generated by the bytecode backend.

use crate::bytecode::{BytecodeModule, Instruction};
use eclexia_ast::dimension::Dimension;
use smol_str::SmolStr;
use std::collections::HashMap;

/// A value on the VM stack
#[derive(Debug, Clone)]
pub enum Value {
    Unit,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(String),
    Char(char),
    Function(usize), // Function index
}

impl Value {
    /// Convert to boolean for conditional jumps
    pub fn as_bool(&self) -> Result<bool, VmError> {
        match self {
            Value::Bool(b) => Ok(*b),
            Value::Int(i) => Ok(*i != 0),
            Value::Float(f) => Ok(*f != 0.0),
            _ => Err(VmError::TypeError("Cannot convert to boolean".to_string())),
        }
    }

    /// Convert to integer
    pub fn as_int(&self) -> Result<i64, VmError> {
        match self {
            Value::Int(i) => Ok(*i),
            Value::Bool(b) => Ok(if *b { 1 } else { 0 }),
            Value::Float(f) => Ok(*f as i64),
            Value::Char(c) => Ok(*c as i64),
            _ => Err(VmError::TypeError("Cannot convert to integer".to_string())),
        }
    }

    /// Convert to float
    pub fn as_float(&self) -> Result<f64, VmError> {
        match self {
            Value::Float(f) => Ok(*f),
            Value::Int(i) => Ok(*i as f64),
            Value::Bool(b) => Ok(if *b { 1.0 } else { 0.0 }),
            _ => Err(VmError::TypeError("Cannot convert to float".to_string())),
        }
    }
}

/// VM execution error
#[derive(Debug, Clone)]
pub enum VmError {
    /// Stack underflow
    StackUnderflow,

    /// Stack overflow
    StackOverflow,

    /// Invalid instruction
    InvalidInstruction(String),

    /// Type error
    TypeError(String),

    /// Missing function
    MissingFunction(usize),

    /// Invalid jump target
    InvalidJump(usize),

    /// Division by zero
    DivisionByZero,

    /// Out of bounds access
    OutOfBounds { index: usize, size: usize },
}

impl std::fmt::Display for VmError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VmError::StackUnderflow => write!(f, "Stack underflow"),
            VmError::StackOverflow => write!(f, "Stack overflow"),
            VmError::InvalidInstruction(msg) => write!(f, "Invalid instruction: {}", msg),
            VmError::TypeError(msg) => write!(f, "Type error: {}", msg),
            VmError::MissingFunction(idx) => write!(f, "Missing function: {}", idx),
            VmError::InvalidJump(target) => write!(f, "Invalid jump target: {}", target),
            VmError::DivisionByZero => write!(f, "Division by zero"),
            VmError::OutOfBounds { index, size } => {
                write!(f, "Out of bounds: index {} >= size {}", index, size)
            }
        }
    }
}

impl std::error::Error for VmError {}

/// Call frame for function calls
#[derive(Debug, Clone)]
struct CallFrame {
    /// Function being executed
    function_idx: usize,

    /// Instruction pointer
    ip: usize,

    /// Base pointer for local variables
    bp: usize,
}

/// Resource tracking entry
#[derive(Debug, Clone)]
struct ResourceUsage {
    /// Resource name
    resource: SmolStr,

    /// Dimension
    dimension: Dimension,

    /// Amount consumed
    amount: f64,
}

/// Virtual machine state
pub struct VirtualMachine {
    /// Bytecode module being executed
    module: BytecodeModule,

    /// Value stack
    stack: Vec<Value>,

    /// Call stack
    call_stack: Vec<CallFrame>,

    /// Local variables (flat array indexed by BP + local_idx)
    locals: Vec<Value>,

    /// Resource usage tracking
    resources: Vec<ResourceUsage>,

    /// Stack size limit
    stack_limit: usize,

    /// Call stack depth limit
    call_limit: usize,
}

impl VirtualMachine {
    /// Create a new VM with the given bytecode module
    pub fn new(module: BytecodeModule) -> Self {
        Self {
            module,
            stack: Vec::new(),
            call_stack: Vec::new(),
            locals: Vec::new(),
            resources: Vec::new(),
            stack_limit: 10000,
            call_limit: 1000,
        }
    }

    /// Execute the module's entry point
    pub fn run(&mut self) -> Result<Value, VmError> {
        let entry_idx = self.module.entry_point
            .ok_or_else(|| VmError::MissingFunction(0))?;

        self.call_function(entry_idx, &[])?;
        self.execute()
    }

    /// Execute a specific function
    pub fn call_function(&mut self, func_idx: usize, args: &[Value]) -> Result<(), VmError> {
        if func_idx >= self.module.functions.len() {
            return Err(VmError::MissingFunction(func_idx));
        }

        if self.call_stack.len() >= self.call_limit {
            return Err(VmError::StackOverflow);
        }

        let func = &self.module.functions[func_idx];

        // Set up call frame
        let bp = self.locals.len();
        let frame = CallFrame {
            function_idx: func_idx,
            ip: 0,
            bp,
        };

        self.call_stack.push(frame);

        // Initialize locals with arguments and allocate space for local variables
        for arg in args {
            self.locals.push(arg.clone());
        }

        // Allocate space for remaining locals
        let remaining_locals = func.local_count.saturating_sub(args.len() as u32);
        for _ in 0..remaining_locals {
            self.locals.push(Value::Unit);
        }

        Ok(())
    }

    /// Main execution loop
    fn execute(&mut self) -> Result<Value, VmError> {
        loop {
            let frame = self.call_stack.last().ok_or(VmError::StackUnderflow)?;
            let func_idx = frame.function_idx;
            let ip = frame.ip;
            let call_depth_before = self.call_stack.len();

            // Clone the instruction to avoid borrow conflicts
            let inst = {
                let func = &self.module.functions[func_idx];
                if ip >= func.instructions.len() {
                    return Err(VmError::InvalidJump(ip));
                }
                func.instructions[ip].clone()
            };

            // Debug
            eprintln!("Exec: func={}, ip={}, inst={:?}, stack={}, locals={}, call_depth={}",
                     func_idx, ip, inst, self.stack.len(), self.locals.len(), call_depth_before);

            // Execute instruction
            match self.execute_instruction(&inst)? {
                ExecutionResult::Continue => {
                    // Increment IP only if we're still in the same function
                    // (Call instructions push a new frame, so we don't want to increment)
                    let call_depth_after = self.call_stack.len();
                    if call_depth_after == call_depth_before {
                        if let Some(frame) = self.call_stack.last_mut() {
                            frame.ip += 1;
                        }
                    }
                }
                ExecutionResult::Jump(target) => {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.ip = target;
                    }
                }
                ExecutionResult::Return(value) => {
                    // Pop call frame
                    self.call_stack.pop();

                    // If no more frames, return the value
                    if self.call_stack.is_empty() {
                        self.locals.clear();
                        return Ok(value);
                    }

                    // Clean up locals - truncate to caller's bp + caller's local count
                    if let Some(frame) = self.call_stack.last() {
                        let caller_func = &self.module.functions[frame.function_idx];
                        let caller_locals_end = frame.bp + caller_func.local_count as usize;
                        self.locals.truncate(caller_locals_end);
                    }

                    // Push return value onto stack
                    self.push(value)?;

                    // Advance caller's IP past the call instruction
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.ip += 1;
                    }
                }
            }
        }
    }

    /// Execute a single instruction
    fn execute_instruction(
        &mut self,
        inst: &Instruction,
    ) -> Result<ExecutionResult, VmError> {
        match inst {
            // Stack operations
            Instruction::PushInt(i) => {
                self.push(Value::Int(*i))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushFloat(f) => {
                self.push(Value::Float(*f))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushBool(b) => {
                self.push(Value::Bool(*b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushString(idx) => {
                let s = self.module.strings.get(*idx)
                    .ok_or_else(|| VmError::OutOfBounds { index: *idx, size: self.module.strings.len() })?;
                self.push(Value::String(s.clone()))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushUnit => {
                self.push(Value::Unit)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LoadLocal(idx) => {
                let bp = self.call_stack.last().ok_or(VmError::StackUnderflow)?.bp;
                let local_idx = bp + (*idx as usize);

                let value = self.locals.get(local_idx)
                    .ok_or_else(|| VmError::OutOfBounds { index: local_idx, size: self.locals.len() })?
                    .clone();

                self.push(value)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::StoreLocal(idx) => {
                let value = self.pop()?;
                let bp = self.call_stack.last().ok_or(VmError::StackUnderflow)?.bp;
                let local_idx = bp + (*idx as usize);

                if local_idx >= self.locals.len() {
                    return Err(VmError::OutOfBounds { index: local_idx, size: self.locals.len() });
                }

                self.locals[local_idx] = value;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Dup => {
                let value = self.peek()?.clone();
                self.push(value)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Pop => {
                self.pop()?;
                Ok(ExecutionResult::Continue)
            }

            // Arithmetic - Integer
            Instruction::AddInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_add(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::SubInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_sub(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::MulInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_mul(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::DivInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                if b == 0 {
                    return Err(VmError::DivisionByZero);
                }
                self.push(Value::Int(a / b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::RemInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                if b == 0 {
                    return Err(VmError::DivisionByZero);
                }
                self.push(Value::Int(a % b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NegInt => {
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(-a))?;
                Ok(ExecutionResult::Continue)
            }

            // Arithmetic - Float
            Instruction::AddFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a + b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::SubFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a - b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::MulFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a * b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::DivFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a / b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NegFloat => {
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(-a))?;
                Ok(ExecutionResult::Continue)
            }

            // Comparison - Integer
            Instruction::EqInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a == b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a != b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LtInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a < b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a <= b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GtInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a > b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a >= b))?;
                Ok(ExecutionResult::Continue)
            }

            // Comparison - Float
            Instruction::EqFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a == b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a != b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LtFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a < b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a <= b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GtFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a > b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a >= b))?;
                Ok(ExecutionResult::Continue)
            }

            // Logical
            Instruction::And => {
                let b = self.pop()?.as_bool()?;
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(a && b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Or => {
                let b = self.pop()?.as_bool()?;
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(a || b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Not => {
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(!a))?;
                Ok(ExecutionResult::Continue)
            }

            // Bitwise
            Instruction::BitAnd => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a & b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitOr => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a | b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitXor => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a ^ b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Shl => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a << b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Shr => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a >> b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitNot => {
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(!a))?;
                Ok(ExecutionResult::Continue)
            }

            // Control flow
            Instruction::Jump(target) => {
                Ok(ExecutionResult::Jump(*target))
            }

            Instruction::JumpIf(target) => {
                let cond = self.pop()?.as_bool()?;
                if cond {
                    Ok(ExecutionResult::Jump(*target))
                } else {
                    Ok(ExecutionResult::Continue)
                }
            }

            Instruction::JumpIfNot(target) => {
                let cond = self.pop()?.as_bool()?;
                if !cond {
                    Ok(ExecutionResult::Jump(*target))
                } else {
                    Ok(ExecutionResult::Continue)
                }
            }

            Instruction::Return => {
                Ok(ExecutionResult::Return(Value::Unit))
            }

            Instruction::ReturnValue => {
                let value = self.pop()?;
                Ok(ExecutionResult::Return(value))
            }

            // Function calls
            Instruction::Call(func_idx, arg_count) => {
                let mut args = Vec::new();
                for _ in 0..*arg_count {
                    args.push(self.pop()?);
                }
                args.reverse();

                self.call_function(*func_idx, &args)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::CallIndirect(_arg_count) => {
                Err(VmError::InvalidInstruction("CallIndirect not yet implemented".to_string()))
            }

            // Resource tracking
            Instruction::TrackResource { resource, dimension } => {
                let amount = self.pop()?.as_float()?;
                self.resources.push(ResourceUsage {
                    resource: resource.clone(),
                    dimension: *dimension,
                    amount,
                });
                Ok(ExecutionResult::Continue)
            }

            Instruction::ShadowPriceHook { resource: _, dimension: _ } => {
                // Shadow price hook - in a real implementation, this would
                // query the runtime for current shadow prices
                Ok(ExecutionResult::Continue)
            }

            // Type operations
            Instruction::Cast { from: _, to: _ } => {
                // Type casts - for now, values are already in the right form
                Ok(ExecutionResult::Continue)
            }

            // Debugging
            Instruction::DebugPrint => {
                let value = self.peek()?;
                println!("DEBUG: {:?}", value);
                Ok(ExecutionResult::Continue)
            }

            Instruction::Nop => Ok(ExecutionResult::Continue),
        }
    }

    /// Push a value onto the stack
    fn push(&mut self, value: Value) -> Result<(), VmError> {
        if self.stack.len() >= self.stack_limit {
            return Err(VmError::StackOverflow);
        }
        self.stack.push(value);
        Ok(())
    }

    /// Pop a value from the stack
    fn pop(&mut self) -> Result<Value, VmError> {
        self.stack.pop().ok_or(VmError::StackUnderflow)
    }

    /// Peek at the top of the stack
    fn peek(&self) -> Result<&Value, VmError> {
        self.stack.last().ok_or(VmError::StackUnderflow)
    }

    /// Get resource usage statistics
    pub fn get_resource_usage(&self) -> HashMap<SmolStr, f64> {
        let mut usage = HashMap::new();
        for res in &self.resources {
            *usage.entry(res.resource.clone()).or_insert(0.0) += res.amount;
        }
        usage
    }
}

/// Result of instruction execution
enum ExecutionResult {
    /// Continue to next instruction
    Continue,

    /// Jump to target instruction
    Jump(usize),

    /// Return from function
    Return(Value),
}
