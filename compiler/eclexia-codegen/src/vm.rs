// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

//! Bytecode virtual machine.
//!
//! Executes bytecode generated by the bytecode backend.

use crate::bytecode::{BytecodeModule, Instruction};
use eclexia_ast::dimension::Dimension;
use eclexia_ast::types::{PrimitiveTy, Ty};
use smol_str::SmolStr;
use std::collections::{HashMap, HashSet};

const TAG_FIELD: &str = "__eclexia_tag";

/// A value on the VM stack
#[derive(Debug, Clone)]
pub enum Value {
    /// Unit value (no data)
    Unit,
    /// Boolean value
    Bool(bool),
    /// 64-bit signed integer
    Int(i64),
    /// 64-bit floating-point number
    Float(f64),
    /// Heap-allocated string
    String(String),
    /// Array value
    Array(Vec<Value>),
    /// Struct-like map
    Struct(HashMap<SmolStr, Value>),
    /// Unicode character
    Char(char),
    /// Function reference by index into the module's function table
    Function(usize),
    /// Exclusive range (start..end)
    Range(i64, i64),
    /// Inclusive range (start..=end)
    RangeInclusive(i64, i64),
}

impl Value {
    /// Convert to boolean for conditional jumps
    pub fn as_bool(&self) -> Result<bool, VmError> {
        match self {
            Value::Bool(b) => Ok(*b),
            Value::Int(i) => Ok(*i != 0),
            Value::Float(f) => Ok(*f != 0.0),
            _ => Err(VmError::TypeError("Cannot convert to boolean".to_string())),
        }
    }

    /// Convert to integer
    pub fn as_int(&self) -> Result<i64, VmError> {
        match self {
            Value::Int(i) => Ok(*i),
            Value::Bool(b) => Ok(if *b { 1 } else { 0 }),
            Value::Float(f) => Ok(*f as i64),
            Value::Char(c) => Ok(*c as i64),
            _ => Err(VmError::TypeError("Cannot convert to integer".to_string())),
        }
    }

    /// Convert to float
    pub fn as_float(&self) -> Result<f64, VmError> {
        match self {
            Value::Float(f) => Ok(*f),
            Value::Int(i) => Ok(*i as f64),
            Value::Bool(b) => Ok(if *b { 1.0 } else { 0.0 }),
            _ => Err(VmError::TypeError("Cannot convert to float".to_string())),
        }
    }
}

/// VM execution error
#[derive(Debug, Clone)]
pub enum VmError {
    /// Stack underflow
    StackUnderflow,

    /// Stack overflow
    StackOverflow,

    /// Invalid instruction
    InvalidInstruction(String),

    /// Type error
    TypeError(String),

    /// Missing function
    MissingFunction(usize),

    /// Invalid jump target
    InvalidJump(usize),

    /// Division by zero
    DivisionByZero,

    /// Out of bounds access
    OutOfBounds { index: usize, size: usize },
}

impl std::fmt::Display for VmError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VmError::StackUnderflow => write!(f, "Stack underflow"),
            VmError::StackOverflow => write!(f, "Stack overflow"),
            VmError::InvalidInstruction(msg) => write!(f, "Invalid instruction: {}", msg),
            VmError::TypeError(msg) => write!(f, "Type error: {}", msg),
            VmError::MissingFunction(idx) => write!(f, "Missing function: {}", idx),
            VmError::InvalidJump(target) => write!(f, "Invalid jump target: {}", target),
            VmError::DivisionByZero => write!(f, "Division by zero"),
            VmError::OutOfBounds { index, size } => {
                write!(f, "Out of bounds: index {} >= size {}", index, size)
            }
        }
    }
}

impl std::error::Error for VmError {}

/// Call frame for function calls
#[derive(Debug, Clone)]
pub struct CallFrame {
    /// Function being executed
    pub function_idx: usize,

    /// Instruction pointer
    pub ip: usize,

    /// Base pointer for local variables
    pub bp: usize,
}

/// Resource tracking entry
#[derive(Debug, Clone)]
pub struct ResourceUsage {
    /// Resource name
    pub resource: SmolStr,

    /// Dimension
    pub dimension: Dimension,

    /// Amount consumed
    pub amount: f64,
}

/// Debug event
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DebugEvent {
    /// Hit a breakpoint
    Breakpoint,
    /// Single step
    Step,
}

/// Action to take after a debug event
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DebugAction {
    /// Continue execution
    Continue,
    /// Step to next instruction
    Step,
    /// Pause execution (return from execute)
    Pause,
}

/// Virtual machine state
pub struct VirtualMachine {
    /// Bytecode module being executed
    module: BytecodeModule,

    /// Value stack
    stack: Vec<Value>,

    /// Call stack
    call_stack: Vec<CallFrame>,

    /// Local variables (flat array indexed by BP + local_idx)
    locals: Vec<Value>,

    /// Resource usage tracking
    resources: Vec<ResourceUsage>,

    /// Stack size limit
    stack_limit: usize,

    /// Call stack depth limit
    call_limit: usize,

    /// Debug mode enabled
    debug_mode: bool,

    /// Breakpoints (function_idx, instruction_idx)
    breakpoints: HashSet<(usize, usize)>,

    /// Single-step mode
    single_step: bool,

    /// Paused at current instruction
    paused: bool,
}

impl VirtualMachine {
    /// Create a new VM with the given bytecode module
    pub fn new(module: BytecodeModule) -> Self {
        Self {
            module,
            stack: Vec::new(),
            call_stack: Vec::new(),
            locals: Vec::new(),
            resources: Vec::new(),
            stack_limit: 10000,
            call_limit: 1000,
            debug_mode: false,
            breakpoints: HashSet::new(),
            single_step: false,
            paused: false,
        }
    }

    /// Enable debug mode
    pub fn enable_debug(&mut self) {
        self.debug_mode = true;
    }

    /// Disable debug mode
    pub fn disable_debug(&mut self) {
        self.debug_mode = false;
        self.single_step = false;
    }

    /// Set a breakpoint at the given function and instruction
    pub fn set_breakpoint(&mut self, func_idx: usize, inst_idx: usize) {
        self.breakpoints.insert((func_idx, inst_idx));
    }

    /// Remove a breakpoint
    pub fn remove_breakpoint(&mut self, func_idx: usize, inst_idx: usize) {
        self.breakpoints.remove(&(func_idx, inst_idx));
    }

    /// Clear all breakpoints
    pub fn clear_breakpoints(&mut self) {
        self.breakpoints.clear();
    }

    /// Enable single-step mode
    pub fn enable_single_step(&mut self) {
        self.single_step = true;
    }

    /// Disable single-step mode
    pub fn disable_single_step(&mut self) {
        self.single_step = false;
    }

    /// Check if execution is paused
    pub fn is_paused(&self) -> bool {
        self.paused
    }

    /// Resume execution
    pub fn resume(&mut self) {
        self.paused = false;
    }

    /// Step one instruction (enables single-step and resumes)
    pub fn step_one(&mut self) {
        self.single_step = true;
        self.paused = false;
    }

    /// Continue execution after a debug pause.
    /// Returns the final value when the program finishes, or `Value::Unit` if paused again.
    pub fn continue_running(&mut self) -> Result<Value, VmError> {
        self.paused = false;
        self.execute()
    }

    /// Step one instruction and return.
    /// Returns `Value::Unit` if paused (normal), or the final value if the program ends.
    pub fn step_instruction(&mut self) -> Result<Value, VmError> {
        self.single_step = true;
        self.paused = false;
        self.execute()
    }

    /// Get current stack
    pub fn get_stack(&self) -> &[Value] {
        &self.stack
    }

    /// Get current locals
    pub fn get_locals(&self) -> &[Value] {
        &self.locals
    }

    /// Get current call stack
    pub fn get_call_stack(&self) -> &[CallFrame] {
        &self.call_stack
    }

    /// Get current resource usage
    pub fn get_resources(&self) -> &[ResourceUsage] {
        &self.resources
    }

    /// Get module
    pub fn get_module(&self) -> &BytecodeModule {
        &self.module
    }

    /// Execute the module's entry point
    pub fn run(&mut self) -> Result<Value, VmError> {
        let entry_idx = self.module.entry_point.ok_or(VmError::MissingFunction(0))?;

        self.call_function(entry_idx, &[])?;
        self.execute()
    }

    /// Execute a specific function
    pub fn call_function(&mut self, func_idx: usize, args: &[Value]) -> Result<(), VmError> {
        if func_idx >= self.module.functions.len() {
            return Err(VmError::MissingFunction(func_idx));
        }

        if self.call_stack.len() >= self.call_limit {
            return Err(VmError::StackOverflow);
        }

        let func = &self.module.functions[func_idx];

        // Set up call frame
        let bp = self.locals.len();
        let frame = CallFrame {
            function_idx: func_idx,
            ip: 0,
            bp,
        };

        self.call_stack.push(frame);

        // Initialize locals with arguments and allocate space for local variables
        for arg in args {
            self.locals.push(arg.clone());
        }

        // Allocate space for remaining locals
        let remaining_locals = func.local_count.saturating_sub(args.len() as u32);
        for _ in 0..remaining_locals {
            self.locals.push(Value::Unit);
        }

        Ok(())
    }

    /// Main execution loop
    fn execute(&mut self) -> Result<Value, VmError> {
        loop {
            let frame = self.call_stack.last().ok_or(VmError::StackUnderflow)?;
            let func_idx = frame.function_idx;
            let ip = frame.ip;
            let call_depth_before = self.call_stack.len();

            // Check for breakpoint or single-step mode
            if self.debug_mode && !self.paused {
                let at_breakpoint = self.breakpoints.contains(&(func_idx, ip));
                if at_breakpoint || self.single_step {
                    // Pause execution
                    self.paused = true;
                    // If single-stepping, disable it so we pause at next instruction
                    if self.single_step {
                        self.single_step = false;
                    }
                    // Return control to debugger
                    return Ok(Value::Unit);
                }
            }

            // Clone the instruction to avoid borrow conflicts
            let inst = {
                let func = &self.module.functions[func_idx];
                if ip >= func.instructions.len() {
                    return Err(VmError::InvalidJump(ip));
                }
                func.instructions[ip].clone()
            };

            // Debug
            if self.debug_mode {
                eprintln!(
                    "Exec: func={}, ip={}, inst={:?}, stack={}, locals={}, call_depth={}",
                    func_idx,
                    ip,
                    inst,
                    self.stack.len(),
                    self.locals.len(),
                    call_depth_before
                );
            }

            // Execute instruction
            match self.execute_instruction(&inst)? {
                ExecutionResult::Continue => {
                    // Increment IP only if we're still in the same function
                    // (Call instructions push a new frame, so we don't want to increment)
                    let call_depth_after = self.call_stack.len();
                    if call_depth_after == call_depth_before {
                        if let Some(frame) = self.call_stack.last_mut() {
                            frame.ip += 1;
                        }
                    }
                }
                ExecutionResult::Jump(target) => {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.ip = target;
                    }
                }
                ExecutionResult::Return(value) => {
                    // Pop call frame
                    self.call_stack.pop();

                    // If no more frames, return the value
                    if self.call_stack.is_empty() {
                        self.locals.clear();
                        return Ok(value);
                    }

                    // Clean up locals - truncate to caller's bp + caller's local count
                    if let Some(frame) = self.call_stack.last() {
                        let caller_func = &self.module.functions[frame.function_idx];
                        let caller_locals_end = frame.bp + caller_func.local_count as usize;
                        self.locals.truncate(caller_locals_end);
                    }

                    // Push return value onto stack
                    self.push(value)?;

                    // Advance caller's IP past the call instruction
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.ip += 1;
                    }
                }
            }
        }
    }

    /// Execute a single instruction
    fn execute_instruction(&mut self, inst: &Instruction) -> Result<ExecutionResult, VmError> {
        match inst {
            // Stack operations
            Instruction::PushInt(i) => {
                self.push(Value::Int(*i))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushFloat(f) => {
                self.push(Value::Float(*f))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushBool(b) => {
                self.push(Value::Bool(*b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushString(idx) => {
                let s = self.module.strings.get(*idx).ok_or(VmError::OutOfBounds {
                    index: *idx,
                    size: self.module.strings.len(),
                })?;
                self.push(Value::String(s.clone()))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PushUnit => {
                self.push(Value::Unit)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LoadLocal(idx) => {
                let bp = self.call_stack.last().ok_or(VmError::StackUnderflow)?.bp;
                let local_idx = bp + (*idx as usize);

                let value = self
                    .locals
                    .get(local_idx)
                    .ok_or(VmError::OutOfBounds {
                        index: local_idx,
                        size: self.locals.len(),
                    })?
                    .clone();

                self.push(value)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::StoreLocal(idx) => {
                let value = self.pop()?;
                let bp = self.call_stack.last().ok_or(VmError::StackUnderflow)?.bp;
                let local_idx = bp + (*idx as usize);

                if local_idx >= self.locals.len() {
                    return Err(VmError::OutOfBounds {
                        index: local_idx,
                        size: self.locals.len(),
                    });
                }

                self.locals[local_idx] = value;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Dup => {
                let value = self.peek()?.clone();
                self.push(value)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Pop => {
                self.pop()?;
                Ok(ExecutionResult::Continue)
            }

            // Arithmetic - Integer
            Instruction::AddInt => {
                let b = self.pop()?;
                let a = self.pop()?;
                match (a, b) {
                    (Value::String(a), Value::String(b)) => {
                        self.push(Value::String(format!("{}{}", a, b)))?;
                    }
                    (Value::String(a), other) => {
                        self.push(Value::String(format!("{}{}", a, self.display_value(&other))))?;
                    }
                    (other, Value::String(b)) => {
                        self.push(Value::String(format!("{}{}", self.display_value(&other), b)))?;
                    }
                    (a, b) => {
                        let a = a.as_int()?;
                        let b = b.as_int()?;
                        self.push(Value::Int(a.wrapping_add(b)))?;
                    }
                }
                Ok(ExecutionResult::Continue)
            }

            Instruction::SubInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_sub(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::MulInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_mul(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::DivInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                if b == 0 {
                    return Err(VmError::DivisionByZero);
                }
                self.push(Value::Int(a / b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::RemInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                if b == 0 {
                    return Err(VmError::DivisionByZero);
                }
                self.push(Value::Int(a % b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NegInt => {
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(-a))?;
                Ok(ExecutionResult::Continue)
            }

            // Arithmetic - Float
            Instruction::AddFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a + b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::SubFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a - b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::MulFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a * b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::DivFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a / b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NegFloat => {
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(-a))?;
                Ok(ExecutionResult::Continue)
            }

            // Comparison - Integer
            Instruction::EqInt => {
                let b = self.pop()?;
                let a = self.pop()?;
                let result = self.values_equal(&a, &b);
                self.push(Value::Bool(result))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NeInt => {
                let b = self.pop()?;
                let a = self.pop()?;
                let result = !self.values_equal(&a, &b);
                self.push(Value::Bool(result))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LtInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a < b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a <= b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GtInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a > b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GeInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Bool(a >= b))?;
                Ok(ExecutionResult::Continue)
            }

            // Comparison - Float
            Instruction::EqFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a == b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::NeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a != b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LtFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a < b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::LeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a <= b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GtFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a > b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::GeFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Bool(a >= b))?;
                Ok(ExecutionResult::Continue)
            }

            // Logical
            Instruction::And => {
                let b = self.pop()?.as_bool()?;
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(a && b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Or => {
                let b = self.pop()?.as_bool()?;
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(a || b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Not => {
                let a = self.pop()?.as_bool()?;
                self.push(Value::Bool(!a))?;
                Ok(ExecutionResult::Continue)
            }

            // Bitwise
            Instruction::BitAnd => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a & b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitOr => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a | b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitXor => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a ^ b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Shl => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a << b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Shr => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a >> b))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::BitNot => {
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(!a))?;
                Ok(ExecutionResult::Continue)
            }

            // Range
            Instruction::Range => {
                let end = self.pop()?.as_int()?;
                let start = self.pop()?.as_int()?;
                self.push(Value::Range(start, end))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::RangeInclusive => {
                let end = self.pop()?.as_int()?;
                let start = self.pop()?.as_int()?;
                self.push(Value::RangeInclusive(start, end))?;
                Ok(ExecutionResult::Continue)
            }

            // Control flow
            Instruction::Jump(target) => Ok(ExecutionResult::Jump(*target)),

            Instruction::JumpIf(target) => {
                let cond = self.pop()?.as_bool()?;
                if cond {
                    Ok(ExecutionResult::Jump(*target))
                } else {
                    Ok(ExecutionResult::Continue)
                }
            }

            Instruction::JumpIfNot(target) => {
                let cond = self.pop()?.as_bool()?;
                if !cond {
                    Ok(ExecutionResult::Jump(*target))
                } else {
                    Ok(ExecutionResult::Continue)
                }
            }

            Instruction::Return => Ok(ExecutionResult::Return(Value::Unit)),

            Instruction::ReturnValue => {
                let value = self.pop()?;
                Ok(ExecutionResult::Return(value))
            }

            // Function calls
            Instruction::Call(func_idx, arg_count) => {
                let mut args = Vec::new();
                for _ in 0..*arg_count {
                    args.push(self.pop()?);
                }
                args.reverse();

                self.call_function(*func_idx, &args)?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::CallIndirect(arg_count) => {
                let func_val = self.pop()?;
                let (func_idx, mut captured) = match func_val {
                    Value::Function(idx) => (idx, Vec::new()),
                    Value::Array(items) => {
                        if items.is_empty() {
                            return Err(VmError::TypeError(
                                "CallIndirect requires a Function value on the stack".to_string(),
                            ));
                        }
                        let mut iter = items.into_iter();
                        let first = iter.next().unwrap();
                        match first {
                            Value::Function(idx) => (idx, iter.collect()),
                            _ => {
                                return Err(VmError::TypeError(
                                    "CallIndirect requires a Function value on the stack".to_string(),
                                ))
                            }
                        }
                    }
                    _ => {
                        return Err(VmError::TypeError(
                            "CallIndirect requires a Function value on the stack".to_string(),
                        ))
                    }
                };

                let mut args = Vec::new();
                for _ in 0..*arg_count {
                    args.push(self.pop()?);
                }
                args.reverse();

                if !captured.is_empty() {
                    let mut all_args = Vec::with_capacity(captured.len() + args.len());
                    all_args.append(&mut captured);
                    all_args.extend(args);
                    self.call_function(func_idx, &all_args)?;
                } else {
                    self.call_function(func_idx, &args)?;
                }
                Ok(ExecutionResult::Continue)
            }

            Instruction::CallBuiltin(name, arg_count) => {
                let mut args = Vec::new();
                for _ in 0..*arg_count {
                    args.push(self.pop()?);
                }
                args.reverse();

                let result = self.execute_builtin(name, &args)?;
                self.push(result)?;
                Ok(ExecutionResult::Continue)
            }

            // Resource tracking
            Instruction::TrackResource {
                resource,
                dimension,
            } => {
                let amount = self.pop()?.as_float()?;
                self.resources.push(ResourceUsage {
                    resource: resource.clone(),
                    dimension: *dimension,
                    amount,
                });
                Ok(ExecutionResult::Continue)
            }

            Instruction::ShadowPriceHook {
                resource: _,
                dimension: _,
            } => {
                // Shadow price hook - in a real implementation, this would
                // query the runtime for current shadow prices
                Ok(ExecutionResult::Continue)
            }

            // Type operations
            Instruction::Cast { from: _, to } => {
                let value = self.pop()?;
                let converted = match to {
                    Ty::Primitive(PrimitiveTy::Int) => Value::Int(value.as_int()?),
                    Ty::Primitive(PrimitiveTy::Float) => Value::Float(value.as_float()?),
                    Ty::Primitive(PrimitiveTy::Bool) => Value::Bool(value.as_bool()?),
                    Ty::Primitive(PrimitiveTy::String) => {
                        let s = match &value {
                            Value::Int(i) => format!("{}", i),
                            Value::Float(f) => format!("{}", f),
                            Value::Bool(b) => format!("{}", b),
                            Value::Char(c) => format!("{}", c),
                            Value::String(s) => s.clone(),
                            Value::Array(items) => {
                                let parts: Vec<String> =
                                    items.iter().map(|v| self.display_value(v)).collect();
                                format!("[{}]", parts.join(", "))
                            }
                            Value::Struct(fields) => {
                                let mut parts: Vec<String> = fields
                                    .iter()
                                    .map(|(k, v)| format!("{}: {}", k, self.display_value(v)))
                                    .collect();
                                parts.sort();
                                format!("{{{}}}", parts.join(", "))
                            }
                            Value::Unit => "()".to_string(),
                            Value::Function(idx) => format!("<function {}>", idx),
                            Value::Range(start, end) => format!("{}..{}", start, end),
                            Value::RangeInclusive(start, end) => format!("{}..={}", start, end),
                        };
                        Value::String(s)
                    }
                    _ => {
                        // For unsupported or identity casts, pass through
                        value
                    }
                };
                self.push(converted)?;
                Ok(ExecutionResult::Continue)
            }

            // Debugging
            Instruction::DebugPrint => {
                let value = self.peek()?;
                println!("DEBUG: {:?}", value);
                Ok(ExecutionResult::Continue)
            }

            // Push function reference
            Instruction::PushFunction(idx) => {
                self.push(Value::Function(*idx))?;
                Ok(ExecutionResult::Continue)
            }

            // Field access (simplified: fields not resolved in VM yet, leave base on stack)
            Instruction::FieldAccess(field) => {
                let base = self.pop()?;
                match base {
                    Value::Struct(fields) => {
                        if let Some(val) = fields.get(field) {
                            self.push(val.clone())?;
                            Ok(ExecutionResult::Continue)
                        } else {
                            Err(VmError::TypeError(format!(
                                "No such field: {}",
                                field
                            )))
                        }
                    }
                    Value::Array(items) if field.as_str() == "len" => {
                        self.push(Value::Int(items.len() as i64))?;
                        Ok(ExecutionResult::Continue)
                    }
                    Value::String(s) if field.as_str() == "len" => {
                        self.push(Value::Int(s.len() as i64))?;
                        Ok(ExecutionResult::Continue)
                    }
                    Value::Range(start, end) if field.as_str() == "len" => {
                        let len = end.saturating_sub(start).max(0) as i64;
                        self.push(Value::Int(len))?;
                        Ok(ExecutionResult::Continue)
                    }
                    Value::RangeInclusive(start, end) if field.as_str() == "len" => {
                        let len = end.saturating_sub(start).max(0) as i64 + 1;
                        self.push(Value::Int(len))?;
                        Ok(ExecutionResult::Continue)
                    }
                    other => Err(VmError::TypeError(format!(
                        "Field access not supported on {}",
                        self.display_value(&other)
                    ))),
                }
            }

            // Index access (simplified: pop index and base, push base back)
            Instruction::IndexAccess => {
                let index = self.pop()?.as_int()? as usize;
                let base = self.pop()?;
                match base {
                    Value::Array(items) => {
                        let value = items.get(index).cloned().ok_or(VmError::OutOfBounds {
                            index,
                            size: items.len(),
                        })?;
                        self.push(value)?;
                        Ok(ExecutionResult::Continue)
                    }
                    Value::String(s) => {
                        let ch = s.chars().nth(index).ok_or(VmError::OutOfBounds {
                            index,
                            size: s.len(),
                        })?;
                        self.push(Value::Char(ch))?;
                        Ok(ExecutionResult::Continue)
                    }
                    Value::Range(start, end) => {
                        let value = start + index as i64;
                        if value >= end {
                            return Err(VmError::OutOfBounds {
                                index,
                                size: (end - start).max(0) as usize,
                            });
                        }
                        self.push(Value::Int(value))?;
                        Ok(ExecutionResult::Continue)
                    }
                    Value::RangeInclusive(start, end) => {
                        let value = start + index as i64;
                        if value > end {
                            return Err(VmError::OutOfBounds {
                                index,
                                size: (end - start + 1).max(0) as usize,
                            });
                        }
                        self.push(Value::Int(value))?;
                        Ok(ExecutionResult::Continue)
                    }
                    _ => Err(VmError::TypeError(
                        "Index access requires array or string".to_string(),
                    )),
                }
            }

            // Set a field on a struct-like value
            Instruction::SetField(field) => {
                let value = self.pop()?;
                let base = self.pop()?;
                let mut fields = match base {
                    Value::Struct(fields) => fields,
                    Value::Unit => HashMap::new(),
                    _ => {
                        return Err(VmError::TypeError(
                            "SetField requires a struct-like value".to_string(),
                        ))
                    }
                };
                fields.insert(field.clone(), value);
                self.push(Value::Struct(fields))?;
                Ok(ExecutionResult::Continue)
            }

            // Set an index on an array-like value
            Instruction::SetIndex => {
                let value = self.pop()?;
                let index = self.pop()?.as_int()? as usize;
                let base = self.pop()?;
                let mut items = match base {
                    Value::Array(items) => items,
                    Value::Unit => Vec::new(),
                    _ => {
                        return Err(VmError::TypeError(
                            "SetIndex requires an array value".to_string(),
                        ))
                    }
                };
                if index >= items.len() {
                    items.resize(index + 1, Value::Unit);
                }
                items[index] = value;
                self.push(Value::Array(items))?;
                Ok(ExecutionResult::Continue)
            }

            // Exponentiation
            Instruction::PowInt => {
                let b = self.pop()?.as_int()?;
                let a = self.pop()?.as_int()?;
                self.push(Value::Int(a.wrapping_pow(b as u32)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::PowFloat => {
                let b = self.pop()?.as_float()?;
                let a = self.pop()?.as_float()?;
                self.push(Value::Float(a.powf(b)))?;
                Ok(ExecutionResult::Continue)
            }

            Instruction::Nop => Ok(ExecutionResult::Continue),
        }
    }

    /// Push a value onto the stack
    fn push(&mut self, value: Value) -> Result<(), VmError> {
        if self.stack.len() >= self.stack_limit {
            return Err(VmError::StackOverflow);
        }
        self.stack.push(value);
        Ok(())
    }

    /// Pop a value from the stack
    fn pop(&mut self) -> Result<Value, VmError> {
        self.stack.pop().ok_or(VmError::StackUnderflow)
    }

    /// Peek at the top of the stack
    fn peek(&self) -> Result<&Value, VmError> {
        self.stack.last().ok_or(VmError::StackUnderflow)
    }

    /// Execute a builtin function by name
    fn execute_builtin(&self, name: &SmolStr, args: &[Value]) -> Result<Value, VmError> {
        match name.as_str() {
            "println" => {
                let parts: Vec<String> = args.iter().map(|a| self.display_value(a)).collect();
                println!("{}", parts.join(" "));
                Ok(Value::Unit)
            }
            "print" => {
                let parts: Vec<String> = args.iter().map(|a| self.display_value(a)).collect();
                print!("{}", parts.join(" "));
                Ok(Value::Unit)
            }
            "to_string" => {
                if args.is_empty() {
                    return Ok(Value::String(String::new()));
                }
                Ok(Value::String(self.display_value(&args[0])))
            }
            "len" => match args.first() {
                Some(Value::String(s)) => Ok(Value::Int(s.len() as i64)),
                Some(Value::Array(items)) => Ok(Value::Int(items.len() as i64)),
                _ => Ok(Value::Int(0)),
            },
            "abs" => match args.first() {
                Some(Value::Int(i)) => Ok(Value::Int(i.abs())),
                Some(Value::Float(f)) => Ok(Value::Float(f.abs())),
                _ => Ok(Value::Int(0)),
            },
            "min" => match (args.first(), args.get(1)) {
                (Some(Value::Int(a)), Some(Value::Int(b))) => Ok(Value::Int(*a.min(b))),
                (Some(Value::Float(a)), Some(Value::Float(b))) => Ok(Value::Float(a.min(*b))),
                _ => Ok(Value::Int(0)),
            },
            "max" => match (args.first(), args.get(1)) {
                (Some(Value::Int(a)), Some(Value::Int(b))) => Ok(Value::Int(*a.max(b))),
                (Some(Value::Float(a)), Some(Value::Float(b))) => Ok(Value::Float(a.max(*b))),
                _ => Ok(Value::Int(0)),
            },
            "sqrt" => match args.first() {
                Some(Value::Float(f)) => Ok(Value::Float(f.sqrt())),
                Some(Value::Int(i)) => Ok(Value::Float((*i as f64).sqrt())),
                _ => Ok(Value::Float(0.0)),
            },
            "floor" => match args.first() {
                Some(Value::Float(f)) => Ok(Value::Int(f.floor() as i64)),
                Some(Value::Int(i)) => Ok(Value::Int(*i)),
                _ => Ok(Value::Int(0)),
            },
            "ceil" => match args.first() {
                Some(Value::Float(f)) => Ok(Value::Int(f.ceil() as i64)),
                Some(Value::Int(i)) => Ok(Value::Int(*i)),
                _ => Ok(Value::Int(0)),
            },
            "pow" => match (args.first(), args.get(1)) {
                (Some(Value::Int(a)), Some(Value::Int(b))) => {
                    Ok(Value::Int(a.wrapping_pow(*b as u32)))
                }
                (Some(Value::Float(a)), Some(Value::Float(b))) => Ok(Value::Float(a.powf(*b))),
                _ => Ok(Value::Int(0)),
            },
            "log" => match args.first() {
                Some(Value::Float(f)) => Ok(Value::Float(f.ln())),
                Some(Value::Int(i)) => Ok(Value::Float((*i as f64).ln())),
                _ => Ok(Value::Float(0.0)),
            },
            "exp" => match args.first() {
                Some(Value::Float(f)) => Ok(Value::Float(f.exp())),
                Some(Value::Int(i)) => Ok(Value::Float((*i as f64).exp())),
                _ => Ok(Value::Float(0.0)),
            },
            "assert" => match args.first() {
                Some(Value::Bool(true)) => Ok(Value::Unit),
                Some(Value::Bool(false)) => Err(VmError::TypeError("Assertion failed".to_string())),
                _ => Err(VmError::TypeError("assert requires a boolean".to_string())),
            },
            "panic" => {
                let msg = args
                    .first()
                    .map(|a| self.display_value(a))
                    .unwrap_or_default();
                Err(VmError::TypeError(format!("panic: {}", msg)))
            }
            "range" => {
                let (start, end) = match (args.first(), args.get(1)) {
                    (Some(Value::Int(a)), Some(Value::Int(b))) => (*a, *b),
                    (Some(Value::Int(end)), None) => (0, *end),
                    _ => return Ok(Value::Unit),
                };
                let mut items = Vec::new();
                for i in start..end {
                    items.push(Value::Int(i));
                }
                Ok(Value::Array(items))
            }
            "file_exists" => match args.first() {
                Some(Value::String(path)) => Ok(Value::Bool(std::path::Path::new(path).exists())),
                _ => Err(VmError::TypeError(
                    "file_exists expects a string path".to_string(),
                )),
            },
            "str_trim" => match args.first() {
                Some(Value::String(s)) => Ok(Value::String(s.trim().to_string())),
                _ => Err(VmError::TypeError(
                    "str_trim expects a string argument".to_string(),
                )),
            },
            "str_split" => {
                if args.len() != 2 {
                    return Err(VmError::TypeError(
                        "str_split expects 2 string arguments".to_string(),
                    ));
                }
                match (&args[0], &args[1]) {
                    (Value::String(s), Value::String(delimiter)) => {
                        let parts: Vec<Value> = s
                            .split(delimiter)
                            .map(|p| Value::String(p.to_string()))
                            .collect();
                        Ok(Value::Array(parts))
                    }
                    _ => Err(VmError::TypeError(
                        "str_split expects two string arguments".to_string(),
                    )),
                }
            },
            "str_contains" => {
                if args.len() != 2 {
                    return Err(VmError::TypeError(
                        "str_contains expects 2 string arguments".to_string(),
                    ));
                }
                match (&args[0], &args[1]) {
                    (Value::String(s), Value::String(sub)) => Ok(Value::Bool(s.contains(sub))),
                    _ => Err(VmError::TypeError(
                        "str_contains expects two string arguments".to_string(),
                    )),
                }
            },
            "str_to_lowercase" => match args.first() {
                Some(Value::String(s)) => Ok(Value::String(s.to_lowercase())),
                _ => Err(VmError::TypeError(
                    "str_to_lowercase expects a string argument".to_string(),
                )),
            },
            "str_to_uppercase" => match args.first() {
                Some(Value::String(s)) => Ok(Value::String(s.to_uppercase())),
                _ => Err(VmError::TypeError(
                    "str_to_uppercase expects a string argument".to_string(),
                )),
            },
            "str_replace" => {
                if args.len() != 3 {
                    return Err(VmError::TypeError(
                        "str_replace expects 3 string arguments".to_string(),
                    ));
                }
                match (&args[0], &args[1], &args[2]) {
                    (Value::String(s), Value::String(from), Value::String(to)) => {
                        Ok(Value::String(s.replace(from, to)))
                    }
                    _ => Err(VmError::TypeError(
                        "str_replace expects three string arguments".to_string(),
                    )),
                }
            },
            "array_sum" => {
                if args.len() != 1 {
                    return Err(VmError::TypeError(
                        "array_sum expects 1 array argument".to_string(),
                    ));
                }
                match &args[0] {
                    Value::Array(arr) => {
                        let mut sum_int: i64 = 0;
                        let mut sum_float: f64 = 0.0;
                        let mut has_float = false;

                        for val in arr {
                            match val {
                                Value::Int(n) => {
                                    if has_float {
                                        sum_float += *n as f64;
                                    } else {
                                        sum_int += n;
                                    }
                                }
                                Value::Float(f) => {
                                    if !has_float {
                                        sum_float = sum_int as f64;
                                        has_float = true;
                                    }
                                    sum_float += f;
                                }
                                _ => return Err(VmError::TypeError(
                                    "array_sum expects an array of numbers".to_string(),
                                )),
                            }
                        }

                        if has_float {
                            Ok(Value::Float(sum_float))
                        } else {
                            Ok(Value::Int(sum_int))
                        }
                    }
                    _ => Err(VmError::TypeError(
                        "array_sum expects an array argument".to_string(),
                    )),
                }
            },
            "read_file" => match args.first() {
                Some(Value::String(path)) => std::fs::read_to_string(path)
                    .map(Value::String)
                    .map_err(|e| VmError::TypeError(format!("read_file failed: {}", e))),
                _ => Err(VmError::TypeError(
                    "read_file expects a string path".to_string(),
                )),
            },
            "write_file" => {
                if args.len() < 2 {
                    return Err(VmError::TypeError(
                        "write_file expects (path, content)".to_string(),
                    ));
                }
                match (&args[0], &args[1]) {
                    (Value::String(path), Value::String(content)) => {
                        std::fs::write(path, content)
                            .map_err(|e| VmError::TypeError(format!("write_file failed: {}", e)))?;
                        Ok(Value::Unit)
                    }
                    _ => Err(VmError::TypeError(
                        "write_file expects (string, string)".to_string(),
                    )),
                }
            }
            _ => {
                // Unknown builtin â€” return Unit rather than crash
                eprintln!("Warning: unknown builtin '{}', returning Unit", name);
                Ok(Value::Unit)
            }
        }
    }

    fn values_equal(&self, a: &Value, b: &Value) -> bool {
        match (a, b) {
            (Value::Unit, Value::Unit) => true,
            (Value::Bool(a), Value::Bool(b)) => a == b,
            (Value::Int(a), Value::Int(b)) => a == b,
            (Value::Float(a), Value::Float(b)) => a == b,
            (Value::Int(a), Value::Float(b)) => (*a as f64) == *b,
            (Value::Float(a), Value::Int(b)) => *a == (*b as f64),
            (Value::Char(a), Value::Char(b)) => a == b,
            (Value::String(a), Value::String(b)) => a == b,
            (Value::Array(a), Value::Array(b)) => {
                if a.len() != b.len() {
                    return false;
                }
                a.iter().zip(b.iter()).all(|(x, y)| self.values_equal(x, y))
            }
            (Value::Struct(a), Value::Struct(b)) => {
                let tag_a = a.get(TAG_FIELD);
                let tag_b = b.get(TAG_FIELD);
                if tag_a != tag_b {
                    return false;
                }
                let mut filtered_a: Vec<(&SmolStr, &Value)> = a
                    .iter()
                    .filter(|(k, _)| k.as_str() != TAG_FIELD)
                    .collect();
                let mut filtered_b: Vec<(&SmolStr, &Value)> = b
                    .iter()
                    .filter(|(k, _)| k.as_str() != TAG_FIELD)
                    .collect();
                if filtered_a.len() != filtered_b.len() {
                    return false;
                }
                filtered_a.sort_by(|(ka, _), (kb, _)| ka.cmp(kb));
                filtered_b.sort_by(|(ka, _), (kb, _)| ka.cmp(kb));
                filtered_a
                    .iter()
                    .zip(filtered_b.iter())
                    .all(|((ka, va), (kb, vb))| ka == kb && self.values_equal(va, vb))
            }
            _ => false,
        }
    }

    /// Format a value for display
    fn display_value(&self, value: &Value) -> String {
        match value {
            Value::Unit => "()".to_string(),
            Value::Bool(b) => b.to_string(),
            Value::Int(i) => i.to_string(),
            Value::Float(f) => format!("{}", f),
            Value::String(s) => s.clone(),
            Value::Char(c) => c.to_string(),
            Value::Array(items) => {
                let parts: Vec<String> = items.iter().map(|v| self.display_value(v)).collect();
                format!("[{}]", parts.join(", "))
            }
            Value::Struct(fields) => {
                let mut parts: Vec<String> = fields
                    .iter()
                    .filter(|(k, _)| k.as_str() != TAG_FIELD)
                    .map(|(k, v)| format!("{}: {}", k, self.display_value(v)))
                    .collect();
                parts.sort();
                format!("{{{}}}", parts.join(", "))
            }
            Value::Function(idx) => format!("<function {}>", idx),
            Value::Range(a, b) => format!("{}..{}", a, b),
            Value::RangeInclusive(a, b) => format!("{}..={}", a, b),
        }
    }

    /// Get resource usage statistics
    pub fn get_resource_usage(&self) -> HashMap<SmolStr, f64> {
        let mut usage = HashMap::new();
        for res in &self.resources {
            *usage.entry(res.resource.clone()).or_insert(0.0) += res.amount;
        }
        usage
    }
}

/// Result of instruction execution
enum ExecutionResult {
    /// Continue to next instruction
    Continue,

    /// Jump to target instruction
    Jump(usize),

    /// Return from function
    Return(Value),
}
